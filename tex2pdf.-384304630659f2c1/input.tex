% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Docker for absolute beginners},
  pdfauthor={Roberto Negro},
  pdflang={es-ES},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={URLCOLOR1},
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{250,250,210}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.61,0.61,0.61}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{spanish}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Definición de colores para usar en el
%% metadata.yaml y en este documento
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{INLINECODECOLOR1}{HTML}{BDDBE2 } %azul gris
\definecolor{URLCOLOR1}{HTML}{CD5C5C} %rojo salmon
\definecolor{TOCCOLOR1}{HTML}{29282A}
\definecolor{TOCCOLOR2}{HTML}{FF4500} %rojo naranja
\definecolor{INLINECODECOLOR2}{HTML}{FFE4B5} %amarillo Moccasin



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Resaltado del código en linea
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[most]{tcolorbox}

%%\colorlet{LightLavender}{Lavender!40!}
\tcbset{on line, 
        boxsep=0pt, left=0.7pt,right=0pt,top=0pt,bottom=0pt,
        colframe=white,colback=INLINECODECOLOR1,  
        highlight math style={enhanced}
        }

% Guardamos la definición original para que nuestra definición no sea recursiva
\let\oldtexttt\texttt
\renewcommand{\texttt}[1]{
    \tcbox{\oldtexttt{#1}} 
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Para generar texto de prueba
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{lipsum}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Configuración para que las líneas
%% de bloques de código se corten y 
%% no ocupen el margen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{fvextra}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Docker for absolute beginners}
\author{Roberto Negro}
\date{11 de diciembre de 2022}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=TOCCOLOR2}
\setcounter{tocdepth}{3}
\tableofcontents
}
\hypertarget{introducciuxf3n}{%
\section{Introducción}\label{introducciuxf3n}}

Una \texttt{imagen\ de\ contenedor} (imagen docker) representa los datos
binarios que encapsulan una aplicación y todas sus dependencia de
software. Las imágenes de contenedor son paquetes de sofware ejecutable
(executable software bundles) que se pueden ejecutar de manera
independiente (run standalone) y que hace suposiciones muy bien
definidas sobre el entorno de ejecución.

Un \texttt{contenedor} es una instancia en ejecución de una imagen. Es
importante tener claro su carácter efímero. Están hechos para poder ser
destruídos y volver a levantar una réplica procedentes de la misma
imagen. Los cambios realizados en un contenedor, por defecto, no
persisten. Es decir, si se elimina y se levanta una replica, se pierden
los cambios. Se pueden montar \texttt{volúmenes} para persistir datos
y/o compartir datos entre contenedores.

\texttt{Docker} es una tecnología que permite gestionar (crear, iniciar,
detener, eliminar) contenedores. \texttt{Docker\ Hub} es el registro de
imágenes de la empresa \texttt{Docker}

Simplicando mucho, podemos ver un contenedor como una pequeña máquina
virtual. Los contenedores se utilizan por varias razones, algunas son
estandarización, portabilidad, aislamiento y rapidez para desplegar
aplicaciones.

Un \texttt{Dockerfile} es un archivo de configuración que sirve para
construir una imagen a partir de otra imagen base.

\texttt{Dockercompose} es un sistema de orquestación de contenedores muy
simple y que no se usa en producción. Utiliza un fichero llamado
\texttt{docker-compose.yml} que puede utilizarse (o no) junto a un
Dockerfile.

\texttt{Kubernetes} es el sistema de orquestación más utilizado en
producción en 2022. Utiliza \texttt{pods} como unidad mínima de
despliegue. Un pod es un set de contenedores, el principal y otros de
soporte. Típicamente, se crea una imagen de contenedor para una
aplicación y se sube a un registro (en producción no se utiliza Docker
Hub, sino \texttt{Nexux} o \texttt{Harbor} entre otros) antes de
referenciar la imagen para que la utilice un Pod.

Las \texttt{redes} constituyen un elemento muy importante tanto en
Docker como en Kubernetes. La red por defecto emnm Docker es
\texttt{bridge}.

\hypertarget{comandos-para-levantar-contenedores}{%
\section{Comandos para levantar
contenedores}\label{comandos-para-levantar-contenedores}}

\hypertarget{descargar-una-imagen}{%
\subsection{Descargar una imagen}\label{descargar-una-imagen}}

Para descargar una imagen (almacenada en DockerHub)

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ pull [OPTIONS] NAME[:TAG}\KeywordTok{|}\ExtensionTok{@DIGEST]}
\ExtensionTok{docker}\NormalTok{ pull }\OperatorTok{\textless{}}\NormalTok{image name}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

utilizará \texttt{latest} si no se especifica el tag.

\hypertarget{levantar-un-contenedor}{%
\subsection{Levantar un contenedor}\label{levantar-un-contenedor}}

Para levantar un contenedor a partir de una imagen (la descarga de
DockerHub si no existe)

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ run [OPTIONS] IMAGE[:TAG}\KeywordTok{|}\ExtensionTok{@DIGEST]}\NormalTok{ [COMMAND] [ARG...]}
\ExtensionTok{docker}\NormalTok{ run }\AttributeTok{{-}d} \AttributeTok{{-}{-}name} \OperatorTok{\textless{}}\NormalTok{set container name}\OperatorTok{\textgreater{}} \OperatorTok{\textless{}}\NormalTok{image name}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

donde \texttt{-d} indica modo \texttt{detached} true, es decir, el
contenedor se ejecute en segundo plano (\texttt{background})

Por defecto, si no se indica \texttt{-d}, se ejecuta en modo
\texttt{foreground}. En este caso, docker run inicia el proceso en el
contenedor y fija (attach) la consola a los procesos STDIN, STDOUT,
STDERR.

Por defecto fija STDIN y STDOUT, pero se puede configurar:

\begin{itemize}
\tightlist
\item
  \texttt{-a={[}{]}} fija STDIN, STDOUT y/o STDERR, por ejemplo
  \texttt{-a\ stdout}
\item
  \texttt{-t} asigna (allocate) una \texttt{pseudo-tty}
\item
  \texttt{-i} mantine STDIN abierto aunque no se fije
\end{itemize}

Para procesos iteractivos, como una shell, se deben utiliza juntos
\texttt{-i\ -t} con el objetivo de asignar una \texttt{tty} para el
proceso del contenedor

\begin{itemize}
\tightlist
\item
  se suele escribir junto \texttt{-it}
\end{itemize}

Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ run }\AttributeTok{{-}it} \AttributeTok{{-}{-}name}\NormalTok{ test busybox sh}
\end{Highlighting}
\end{Shaded}

\hypertarget{flag-rm}{%
\subsection{Flag –rm}\label{flag-rm}}

El flag \texttt{-\/-rm} sirve para eliminar el filesystem que por
defecto persiste después de su muerte (volumen anónimo). Ayuda a no
sobrecargar el disco después de ejecutar contenedores de vida corta.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ run }\AttributeTok{{-}{-}rm} \AttributeTok{{-}it}\NormalTok{ python:3 python}
\end{Highlighting}
\end{Shaded}

Los volúmenes anónimos se guardan normalmente en algún lugar de
\texttt{/var/lib/docker}, comprobarlo con

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ inspect }\AttributeTok{{-}{-}type}\NormalTok{ container }\AttributeTok{{-}f} \StringTok{\textquotesingle{}\{\{range $i, $v := .Mounts \}\}\{\{printf "\%v\textbackslash{}n" $v\}\}\{\{end\}\}\textquotesingle{}} \OperatorTok{\textless{}}\NormalTok{container name}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{utilizando-variables-de-entorno}{%
\subsection{Utilizando variables de
entorno}\label{utilizando-variables-de-entorno}}

Flag de \texttt{docker\ run} para introducir variables de entorno

\begin{itemize}
\tightlist
\item
  \texttt{-e\ "\textless{}env=value\textgreater{}"}
\end{itemize}

\hypertarget{exposiciuxf3n-de-puertos}{%
\subsection{Exposición de puertos}\label{exposiciuxf3n-de-puertos}}

Flag de \texttt{docker\ run} para abrir y mapear puertos

\begin{itemize}
\tightlist
\item
  \texttt{-p\ \textless{}hostPort\textgreater{}:\textless{}containerPort\textgreater{}}
  expone un puerto del contenedor al host (mapeo)
\end{itemize}

El puerto expuesto es accesible en el host y los puertos están
disponibles para cualquier cliente que pueda llegar al host.

Formato para la exposición de puertos - EXPOSE (incoming ports)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort | containerPort}
\end{Highlighting}
\end{Shaded}

**NOTA.* El número de puerto dentro del contenedor (donde el servicio
escucha) no necesariamente coincide (match) con el número de puerto
expuesto fuera del contenedor (donde el cliente conecta). Por ejemplo,
en el contenedor un servicio HTTP esta escuchando en el puerto 80
(\texttt{EXPOSE\ 80} en el Dockerfile). En tiempo de ejecución, el
puerto podría vincularse (bound) con el puerto 42800 en el host.

Se pueden listar los mapes de los puertos del host y los puertos
expuestos con la orden

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ port CONTAINER [PRIVATE\_PORT[/PROTO]]}
\ExtensionTok{docker}\NormalTok{ port }\OperatorTok{\textless{}}\NormalTok{container name}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{orquestar-contenedores-con-docker-compose}{%
\section{Orquestar contenedores con docker
compose}\label{orquestar-contenedores-con-docker-compose}}

\hypertarget{comandos-para-levantar-contenedores-con-docker-compose}{%
\subsection{Comandos para levantar contenedores con
docker-compose}\label{comandos-para-levantar-contenedores-con-docker-compose}}

Se ejecuta desde la carpeta que contiene el \texttt{docker-compose.yml}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker{-}compose}\NormalTok{ up }\AttributeTok{{-}d}
\end{Highlighting}
\end{Shaded}

donde \texttt{-d} es para que el contenedor se ejecute en segundo plano.

El archivo \texttt{docker-compose.yml} puede hacer referencia a un
Dockerfile o descargar la imagen de un almacen remoto.

\hypertarget{comandos-para-gestionar-contenedores}{%
\subsection{Comandos para gestionar
contenedores}\label{comandos-para-gestionar-contenedores}}

\hypertarget{comandos-para-manejar-imagenes}{%
\subsection{Comandos para manejar
imagenes}\label{comandos-para-manejar-imagenes}}

\begin{itemize}
\tightlist
\item
  \texttt{docker\ images} lista las imágenes
\item
  \texttt{docker\ rmi\ \textless{}imagen\textgreater{}} elimina una
  imagen
\item
  \texttt{docker\ system\ prune} elimina imágenes, contenedores,
  volúmenes y dispositivos de red, que no estén asociadas a ningún
  contenedor
\item
  \texttt{docker\ system\ prune\ -a} elimina todos los contenedores
  parados y todas las imágenes que no se están usando en ese momento
\end{itemize}

\hypertarget{comandos-para-manejar-contenedores}{%
\subsection{Comandos para manejar
contenedores}\label{comandos-para-manejar-contenedores}}

\begin{itemize}
\tightlist
\item
  \texttt{docker\ ps\ -a} lista los contenedores que tengo
\item
  \texttt{docker\ ps\ -a\ -q} lista los ids de los contenedores que
  tengo
\item
  \texttt{docker\ ps} lista los contenedores que están corriendo
\item
  \texttt{docker\ ps\ -q} lista los ids de los contenedores que están
  corriendo
\item
  \texttt{docker\ inspect\ \textless{}container\textgreater{}} da
  información sobre el contenedor
\item
  \texttt{docker\ start\ \textless{}container\textgreater{}} arranca un
  contenedor
\item
  \texttt{docker\ stop\ \textless{}container\textgreater{}} para un
  contenedor
\item
  \texttt{docker\ rm\ \textless{}container\textgreater{}} elimina un
  contenedor
\item
  \texttt{docker\ rm\ -f\ \textless{}container\textgreater{}} fuerza la
  eliminación de un contenedor
\item
  \texttt{docker\ exec\ -ti\ \textless{}container\textgreater{}\ bash}
  entra dentro de un contenedor
\end{itemize}

Comando para detener y borrar todos los contenedores:

\begin{itemize}
\tightlist
\item
  \texttt{\$\ docker\ stop\ \$(sudo\ docker\ ps\ -a\ -q)}
\item
  \texttt{\$\ docker\ rm\ \$(sudo\ docker\ ps\ -a\ -q)}
\end{itemize}

\hypertarget{comandos-de-redes}{%
\subsection{Comandos de redes}\label{comandos-de-redes}}

\begin{itemize}
\tightlist
\item
  \texttt{docker\ network\ ls} lista las redes que tengo
\item
  \texttt{docker\ network\ connect\ \textless{}id\ red\textgreater{}\ \textless{}id\ contenedor\textgreater{}}
  conecta un contenedor a una red
\item
  \texttt{docker\ network\ inspect\ \textless{}id\ red\textgreater{}} da
  información sobre la red
\end{itemize}

\hypertarget{comandos-para-manejar-voluxfamenes}{%
\subsection{Comandos para manejar
volúmenes}\label{comandos-para-manejar-voluxfamenes}}

\begin{itemize}
\tightlist
\item
  \texttt{docker\ volume\ create\ \textless{}nombre\ al\ volumen\textgreater{}}
  crea un volumnen
\item
  \texttt{docker\ volume\ ls} lista los volúmenes creados
\item
  \texttt{docker\ volume\ inspect\ \textless{}volumen\textgreater{}}
  inspeciona donde está guardado el volumen
\item
  \texttt{docker\ run\ -it\ -v\ \textless{}volumen\textgreater{}:\textless{}punto\ montaje\ en\ el\ contenedor\textgreater{}\ ubuntu:latest}
  arrancar ubuntu enlazando con el volumen creado
\item
  \texttt{docker\ volume\ rm\ \textless{}volumen\textgreater{}} elimina
  un volumen
\item
  \texttt{docker\ volume\ prune} elimina todos los volúmenes que no
  están siendo usados por ningún contenedor
\end{itemize}

En el curso borré 25 GB de volúmenes.

\hypertarget{construcciuxf3n-de-imuxe1genes-con-dockerfile}{%
\section{Construcción de imágenes con
Dockerfile}\label{construcciuxf3n-de-imuxe1genes-con-dockerfile}}

\hypertarget{comando-para-construir-una-imagen-con-un-dockerfile}{%
\subsection{Comando para construir una imagen con un
Dockerfile}\label{comando-para-construir-una-imagen-con-un-dockerfile}}

Para construir una imagen a partir de un Dockerfile

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ build [OPTIONS] PATH }\KeywordTok{|} \ExtensionTok{URL} \KeywordTok{|} \ExtensionTok{{-}}
\ExtensionTok{docker}\NormalTok{ build }\AttributeTok{{-}t} \OperatorTok{\textless{}}\NormalTok{nombre para la imagen}\OperatorTok{\textgreater{}} \OperatorTok{\textless{}}\NormalTok{ruta del Dockerfile}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Si lo ejecutamos de la carperta del Dockerfile se puede pasar un punto
\texttt{.} para indicar directorio actual.

Para instanciar un contenedor a partir de la imagen creada

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ run }\AttributeTok{{-}d} \AttributeTok{{-}{-}name} \OperatorTok{\textless{}}\NormalTok{nombre para el contenedor}\OperatorTok{\textgreater{}} \OperatorTok{\textless{}}\NormalTok{imagen}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{instrucciones-para-esccribir-un-dockerfile}{%
\subsection{Instrucciones para esccribir un
Dockerfile}\label{instrucciones-para-esccribir-un-dockerfile}}

Sintaxis utilizada en un Dockerfile. El formato es el siguiente

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Comment}
\NormalTok{INSTRUCTION arguments}
\end{Highlighting}
\end{Shaded}

\hypertarget{instrucciones-buxe1sicas}{%
\subsubsection{Instrucciones básicas}\label{instrucciones-buxe1sicas}}

\begin{itemize}
\item
  \texttt{FROM\ \textless{}image:tag\textgreater{}} especifica la imagen
  base
\item
  \texttt{ENV\ \textless{}key\textgreater{}\ \textless{}value\textgreater{}}
  establece una variable de entorno persistente
\item
  \texttt{ARG} define una variable usable en el resto del Dockerfile con
  la sintaxis \texttt{\$\{NOMBRE\_DEL\_ARG\}}
\item
  \texttt{COPY} copia archivos y directorios al contenedor
\item
  \texttt{ADD} idem anterior y además puede descomprimir archivos
  \texttt{.tar} y \texttt{añadir\ archivos\ vía\ URL}
\item
  \texttt{WORKDIR} indica el directorio sobre el que se van a aplicar
  las instrucciones siguientes
\end{itemize}

\hypertarget{ejecuciuxf3n-de-comandos-y-punto-de-entrada}{%
\subsubsection{Ejecución de comandos y punto de
entrada}\label{ejecuciuxf3n-de-comandos-y-punto-de-entrada}}

El Entrypoint de Docker define el comando a ejecutar por defecto cuando
se inicia el contenedor a partir de su imagen. Docker tiene por defecto
el Entrypoint \texttt{/bin/sh\ -c} pero este se puede sobrescribir con
la instrucción ENTRYPOINT.

\begin{itemize}
\tightlist
\item
  \texttt{ENTRYPOINT} indica el ejecutable que utilizará el contenedor
  cuando se inicia
\item
  \texttt{CMD} indica los argumentos que se pasan al ejecutable del
  ENTRYPOINT
\end{itemize}

\textbf{¡Inportante!} Cuando iniciamos un contenedor, podemos indicar
una lista de argumentos que le queremos proporcionar:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{docker}\NormalTok{ run }\OperatorTok{\textless{}}\NormalTok{image}\OperatorTok{\textgreater{}} \OperatorTok{\textless{}}\NormalTok{arg1}\OperatorTok{\textgreater{}} \OperatorTok{\textless{}}\NormalTok{arg2}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Los argumentos que usemos sobrescribirán el valor de \texttt{CMD} en
caso de haberlo y serán ejecutados junto con el comando del
\texttt{ENTRYPOINT}.

\begin{itemize}
\tightlist
\item
  \texttt{RUN} ejecuta una instrucción y crea una imagen (instalar
  paquetes en el contenedor)
\end{itemize}

\hypertarget{configurar-entrypont-del-contenedor}{%
\subsubsection{Configurar entrypont del
contenedor}\label{configurar-entrypont-del-contenedor}}

\begin{itemize}
\tightlist
\item
  \texttt{EXPOSE} indica que puerto del contenedor se debe exponer al
  ejecutarlo (no lo expone directamente)
\item
  \texttt{LABEL} para aportar meta-datos a la imagen
\item
  \texttt{VOLUME} crea un directorio sobre el que se va a montar un
  volumen para persistencia de datos
\item
  \texttt{USER} establece el usuario que se va a usar cuando se ejecute
  cualquier operación posterior con RUN, CMD y ENTRYPOINT
\item
  \texttt{SHELL} permite especificar el uso de otra terminal como zsh,
  csh, tcsh, powershell
\item
  \texttt{STOPSIGNAL} indica una señal que va a finalizar el contenedor
\item
  \texttt{HEALTHCHECK} indica a Docker una manera de testear el
  contenedor para verificar que sigue funcionando correctamente
\item
  \texttt{ONBUILD} cuando la imagen donde se encuentra se use como base
  de otra imagen, va a actuar de trigger y va a ejecutar el comando que
  le indiquemos
\end{itemize}

Ejemplo de un Dockerfile:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{FROM}\NormalTok{ centos}
\ExtensionTok{RUN}\NormalTok{ yum install }\AttributeTok{{-}y}\NormalTok{ java{-}11{-}openjdk{-}devel}
\ExtensionTok{VOLUME}\NormalTok{ /tmp}
\ExtensionTok{ADD}\NormalTok{ prueba{-}0.0.1{-}SNAPSHOT.jar app.jar}
\ExtensionTok{COPY}\NormalTok{ ./holamundo.txt /home/Escritorio/Docker/holamundo.txt}
\ExtensionTok{RUN}\NormalTok{ sh }\AttributeTok{{-}c} \StringTok{\textquotesingle{}touch /app.jar\textquotesingle{}} 
\ExtensionTok{EXPOSE}\NormalTok{ 9090}
\ExtensionTok{ENTRYPOINT}\NormalTok{ [}\StringTok{"java"}\NormalTok{,}\StringTok{"{-}Djava.security.egd=file:/dev/./urandom"}\NormalTok{,}\StringTok{"{-}jar"}\NormalTok{,}\StringTok{"/app.jar"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}


\end{document}
